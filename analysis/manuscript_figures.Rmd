---
title: "manuscript_figures"
author: "Tina Lasisi"
date: "2023-11-08"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---


```{r setup}
# Load required packages
library(tidyverse)
library(patchwork)

knitr::opts_knit$set(root.dir = "..")
knitr::opts_chunk$set(eval = TRUE, echo = FALSE, fig.width = 7, fig.height = 6)

```


## European American vs African American probability of match

```{r erlich-functions}

# Define genome size and number of chromosomes
genome_size = 35 
num_chrs = 22

# Function to calculate the probability of a match for direct relatives
p_match = function(g, m, min_num_seg)
{
  m = m / 100 # Convert m from cM to fraction
  f = exp(-2 * g * m) / 2^(2 * g - 2) # Calculate f value
  pr = 1 - pbinom(min_num_seg - 1, num_chrs + genome_size * 2 * g, f) # Calculate probability
  return(pr)
}

# Function to calculate the probability of a match for once removed relatives
p_match_or = function(g, m, min_num_seg) 
{
  m = m / 100 # Convert m from cM to fraction
  f = exp(-(2 * g + 1) * m) / 2^(2 * g - 1) # Calculate f value
  pr = 1 - pbinom(min_num_seg - 1, num_chrs + genome_size * (2 * g + 1), f) # Calculate probability
  return(pr)
}

# Function to calculate the coverage of the database
coverage = function(Ks, maxg, N_pop, r, m, min_num_seg, min_num_rel, rep_direct = rep(1, 10), rep_or = rep(1, 10))
{
  N = N_pop / 2 # Convert population size to couple size
  pr_succ = length(Ks) # Initialize the vector of probabilities of success
  
  # Loop through database sizes
  for (i in 1:length(Ks)) 
  {
    K = Ks[i] # Current database size
    K_same = round(K * (r / 2) / (1 + r / 2)) # Calculate the number of direct relatives
    K_or = round(K * 1 / (1 + r / 2)) # Calculate the number of once removed relatives
    
    # Initialize vectors for probability calculations
    p_no_coal = numeric(maxg) 
    p_coal = numeric(maxg)
    p_no_coal_or = numeric(maxg) 
    p_coal_or = numeric(maxg)
    Ns = N * (r / 2)^(-(1:(maxg + 1))) # Calculate Ns values
    tot_p = 0
    tot_p_or = 0
    
    # Loop through generations
    for (g in 1:maxg)
    {
      f = 2^(2 * g - 2) / Ns[g] # Calculate f value for direct relatives
      f_or = 2^(2 * g - 1) / Ns[g + 1] # Calculate f value for once removed relatives
      
      # Update probabilities
      if (g > 1) {
        p_coal[g] = p_no_coal[g - 1] * f
        p_no_coal[g] = p_no_coal[g - 1] * (1 - f)
        p_coal_or[g] = p_no_coal_or[g - 1] * f_or
        p_no_coal_or[g] = p_no_coal_or[g - 1] * (1 - f_or)
      } else {
        p_coal[g] = f 
        p_no_coal[g] = 1 - f 
        p_coal_or[g] = f_or 
        p_no_coal_or[g] = 1 - f_or
      }
      
      # Update total probabilities
      tot_p = tot_p + p_coal[g] * p_match(g, m, min_num_seg) * rep_direct[g] 
      if (g < maxg) {
        tot_p_or = tot_p_or + p_coal_or[g] * p_match_or(g, m, min_num_seg) * rep_or[g]
      } 
    }

    # Calculate probability of no success
    pr_no_succ = 0
    for (n in 0:(min_num_rel - 1)) 
    {
      for (n_or in 0:n) 
      {
        pr_no_succ = pr_no_succ + dbinom(n_or, K_or, tot_p_or) * dbinom(n - n_or, K_same, tot_p)
      }
    }
    
    # Calculate the probability of success
    pr_succ[i] = 1 - pr_no_succ
  }
  
  return(pr_succ)
}

# Ks: A vector of database sizes
# maxg: Maximum relatedness to consider (1: sibs, 2: 1st cousins, 3: 2nd cousins...)
# N: Population size

# r: Mean number of children per mating pair (=per family), so 2 for a constant size population, >2 for expanding population, <1 for contracting population
# m: Maximum length in cM of a detectable segment
# min_num_seg: Minimum number of segments to declare a match
# min_num_rel: Minimum number of detected matches (=relatives) to declare success of identification


```

```{r}
library(ggplot2)
library(ggrepel)

generate_plot <- function(rep_direct, rep_or, N_pop, name) {
  N = N_pop # population size
  num_K = 10000 # number of data points between 0 to 1 
  m = 6 # minimal cM
  min_num_seg = 2 # number of segments
  r = 2.5 # number of kids per couple
  Ks = round(seq(from=N/num_K, to=N, length.out=num_K))
  
  c1 = coverage(Ks, maxg = 2, N_pop, r, m, min_num_seg = 2, min_num_rel = 1, rep_direct = rep_direct, rep_or = rep_or)
  c2 = coverage(Ks, maxg = 3, N_pop, r, m, min_num_seg = 2, min_num_rel = 1, rep_direct = rep_direct, rep_or = rep_or)
  c3 = coverage(Ks, maxg = 4, N_pop, r, m, min_num_seg = 2, min_num_rel = 1, rep_direct = rep_direct, rep_or = rep_or)
  c4 = coverage(Ks, maxg = 5, N_pop, r, m, min_num_seg = 2, min_num_rel = 1, rep_direct = rep_direct, rep_or = rep_or)
  
  # Combine the data points into a single data frame
  plot_data <- data.frame(Ks = rep(Ks, 4),
                          Coverage = c(c1, c2, c3, c4),
                          Relationship = factor(rep(c("1C", "2C", "3C", "4C"), each = num_K)))
  
  # Calculate database size as a proportion of the population size
  plot_data$Ks_proportion <- plot_data$Ks / N
  
  # Filter out rows with missing values and ensure x-axis limits are respected
  plot_data <- plot_data[complete.cases(plot_data) & plot_data$Ks_proportion <= 0.05,]
  
  # Find the optimal point for labels
  optimal_x <- mean(plot_data$Ks_proportion)
  plot_data$optimal_label <- abs(plot_data$Ks_proportion - optimal_x) < 0.0001
  
  # Create a ggplot2 plot
  p <- ggplot(plot_data, aes(x = Ks_proportion, y = Coverage, color = Relationship, group = Relationship)) +
    geom_point() +
    geom_line() +
    scale_x_continuous(breaks = seq(0, 0.05, 0.01), limits = c(0, 0.05)) +
    labs(title = name,
         x = "Database Size / Population Size",
         y = "Probability of a Match",
         color = "Cousin Relationship") +
    theme_minimal() +
    theme(legend.position = "right") 
    # geom_text_repel(data = subset(plot_data, optimal_label), 
    #                 aes(label = Relationship, x = Ks_proportion, y = Coverage),
    #                 box.padding = unit(0.5, "lines"),
    #                 point.padding = unit(0.5, "lines"),
    #                 nudge_x = 0.005,
    #                 nudge_y = 0.005,
    #                 show.legend = FALSE)
  
  # Display the plot
  p
}

```

### IBD accounted

```{r ea-fig}

rep_direct_ea = rep(1, 10)
rep_or_ea = rep(1, 10)
N_pop_ea_1990 = 199686070

ea_fig <- generate_plot(rep_direct_ea, rep_or_ea, N_pop_ea_1990, "European Americans")



```

```{r aa-fig, fig.width=10}

rep_direct_aa = rep(2.4, 10)
rep_or_aa = rep(2.4, 10)
N_pop_aa_1990 = 29986060

aa_fig <- generate_plot(rep_direct_aa, rep_or_aa, N_pop_aa_1990, "African Americans")

library(patchwork)
(ea_fig + aa_fig) + plot_layout(guides = "collect")
```

```{r}

generate_plot2 <- function(rep_direct, rep_or, N_pop, name) {
  N = N_pop
  num_K = 10000
  m = 6
  min_num_seg = 2
  r = 2.5
  Ks = round(seq(from=N/num_K, to=N, length.out=num_K))
  
  c1 = coverage(Ks, maxg = 2, N_pop, r, m, min_num_seg = 2, min_num_rel = 1, rep_direct = rep_direct, rep_or = rep_or)
  c2 = coverage(Ks, maxg = 3, N_pop, r, m, min_num_seg = 2, min_num_rel = 1, rep_direct = rep_direct, rep_or = rep_or)
  c3 = coverage(Ks, maxg = 4, N_pop, r, m, min_num_seg = 2, min_num_rel = 1, rep_direct = rep_direct, rep_or = rep_or)
  c4 = coverage(Ks, maxg = 5, N_pop, r, m, min_num_seg = 2, min_num_rel = 1, rep_direct = rep_direct, rep_or = rep_or)
  
  plot_data <- data.frame(Ks = rep(Ks, 4),
                          Coverage = c(c1, c2, c3, c4),
                          Relationship = factor(rep(c("1C", "2C", "3C", "4C"), each = num_K)))
  
  plot_data$Ks_proportion <- plot_data$Ks / N
  
  plot_data <- plot_data[complete.cases(plot_data) & plot_data$Ks_proportion <= 0.2,]
  
  min_coverage <- min(plot_data$Coverage, na.rm = TRUE) # calculate the minimum coverage
  
  p <- ggplot(plot_data, aes(x = Ks_proportion, y = Coverage, color = Relationship, group = Relationship)) +
    geom_point() +
    geom_line() +
    geom_vline(xintercept = 0.025, color = "orange", show.legend = FALSE) +
    geom_vline(xintercept = 0.125, color = "red", show.legend = FALSE) +
    geom_vline(xintercept = 0.08, color = "lightgreen", show.legend = FALSE) +
    geom_vline(xintercept = 0.04, color = "darkgreen", show.legend = FALSE) +
    geom_text(aes(x = 0.025, label = "AA DTC"), y = min_coverage, hjust = 1, vjust = 0, show.legend = FALSE, color = "black") +
    geom_text(aes(x = 0.125, label = "AA CODIS"), y = min_coverage, hjust = -0.1, vjust = 1.1, show.legend = FALSE, color = "black") +
    geom_text(aes(x = 0.08, label = "EA DTC"), y = min_coverage, hjust = -0.1, vjust = 1.1, show.legend = FALSE, color = "black") +
    geom_text(aes(x = 0.04, label = "EA CODIS"), y = min_coverage, hjust = -0.1, vjust = 1.1, show.legend = FALSE, color = "black") +
    scale_color_manual(values = c("1C" = "#ADD8E6", "2C" = "#1E90FF", "3C" = "#00008B", "4C" = "#000080")) + 
    labs(title = name,
         x = "Database Size / Population Size",
         y = "Probability of a Match",
         color = "Relationship") +
    theme_minimal()
  
  p
}

```

```{r combo-fig}

rep_direct_ea = rep(1, 10)
rep_or_ea = rep(1, 10)
N_pop_1990 = 2.5e8

combo_fig <- generate_plot2(rep_direct_ea, rep_or_ea, N_pop_1990, "US")

combo_fig



```
