---
title: "Analyses"
author: "Tina Lasisi"
date: "`r format(Sys.time(), '%Y-%m-%d %H:%M:%S')`"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---


```{r setup}
# Load necessary packages
library(wesanderson) # for color palettes
library(tidyverse) #data wrangling etc

# Set path to the data file
path <- file.path(".", "data")
savepath <- file.path(".", "output")

# Set up vector for cousin degree
p <- c(1:8) 

# Set up initial population size
N <- 76e6

# Set up vector of database sizes to test
DB.sizes <- c(1e6, 5e6, 10e6)

# Set color palette for graphs
my.cols <- wes_palette("Darjeeling1")
```


```{r}
# Read in data on US population sizes by year
US_pop <- read.csv(file.path(path,"est-pop-combo.csv"))

# Calculate number of grandparents by generation
# p_grandpar_gen <- 1950 - 30 * (p + 1)
p_grandpar_gen <- 1990 - 30 * (p + 1)

# Get population sizes by year for grandparents' generation

US_Ns <- US_pop %>% 
  filter(Year %in% p_grandpar_gen)

# Scale population size down by 50% (assumed number of potential parents) and 90% of those have children + set minimum for populations
# 
# N <- US_Ns %>%
#   mutate(across(!Year, ~ . * 0.5 * 0.9))

N <- US_Ns %>%
  mutate(across(!Year, ~ case_when(. * 0.5 * 0.9 < 1e6 ~ 1e6,
                                   TRUE ~ . * 0.5 * 0.9)))

# Set up vector of database sizes to test
DB.sizes <- c(1e6, 5e6, 10e6)

# Set color palette for graphs
my.cols <- wes_palette("Darjeeling1")

```


```{r func-calc-N}

# Calculate number of grandparents by generation
calc_grandparent_gen <- function(year, p = c(1:8)) {
  grandparent_gen <- year - 30 * (p + 1)
  return(grandparent_gen)
}

# Define a function to calculate final population sizes based on input data file and generation of grandparents
calc_final_N <- function(file_path, p_grandpar_gen) {

  # Read in data on US population sizes by year
  US_pop <- read.csv(file_path)
  
  names(US_pop)[1] <- "Year"

  # Get population sizes by year for grandparents' generation
  US_Ns <- US_pop %>% 
    filter(Year %in% p_grandpar_gen)

  # Scale population size down by 50% (assumed number of potential parents) and 90% of those have children + set minimum for populations
  N <- US_Ns %>%
    mutate(across(!Year, ~ case_when(. * 0.5 * 0.9 < 1e6 ~ 1e6,
                                     TRUE ~ . * 0.5 * 0.9)))

  return(N)
}

# get file
US_pop_fp <- file.path(path, "est-pop-combo.csv")
US_pop_coop_fp <- file.path(path, "US_popsize.csv")


```


```{r}

p_grandpar_gen <- calc_grandparent_gen(1990)

N <- calc_final_N(US_pop_fp, p_grandpar_gen)

```

```{r pop-size}

# Define the population sizes and names
populations <- N %>% 
  pivot_longer(-Year, names_to = "Population", values_to = "N")

# Create a ggplot object to visualize population sizes
pop_size_plot <- ggplot(populations, aes(x = Population, y = N)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  labs(x = "Population", y = "Population size") +
  theme_minimal() +
  facet_wrap(~Year)

# Display the plot
print(pop_size_plot)

```



## Probability of p-th degree cousin 


```{r plt-cousins-new}

library(wesanderson)
library(ggplot2)

# Function to calculate probabilities for finding a p-th degree cousin
calc_prob <- function(p, DB.size, N) {
  prob.no.rellys <- exp(-2^(2*p - 2) * DB.size / N)
  return(1 - prob.no.rellys)
}

# Function to calculate probabilities for different database fractions
calc_prob_db_frac <- function(p, DB.sizes, db.frac, N) {
  data <- data.frame(p = integer(), Population = character(), DB.size = double(), Probability = double(), Fraction = double())

  for (pop_name in names(N)) {
    for (i in 1:length(db.frac)) {
      for (j in 1:length(DB.sizes)) {
        DB.size <- DB.sizes[j] * db.frac[i]
        prob <- calc_prob(p, DB.size, N[[pop_name]])
        data <- rbind(data, data.frame(p = p, Population = rep(pop_name, length(p)), DB.size = rep(DB.sizes[j], length(p)), Probability = prob, Fraction = rep(db.frac[i], length(p))))
      }
    }
  }

  return(data)
}


# Function to generate ggplot object
ggplot_prob <- function(data, my.cols) {
  plot <- ggplot(data, aes(x = p, y = Probability, color = factor(DB.size), group = factor(DB.size))) +
    geom_point() +
    geom_line() +
    scale_color_manual(values = my.cols, name = "Database size (Millions)", 
                       labels = format(unique(data$DB.size) / 1e6, dig = 1)) +
    labs(x = "p (degree of cousin)", y = "Probability of at least one p-th cousin in database") +
    theme_minimal() +
    facet_grid(Fraction ~ Population, labeller = labeller(Fraction = function(x) sprintf("%.0f%%", as.numeric(x) * 100)))

  return(plot)
}

# Set color palette for graphs
my.cols <- wes_palette("Darjeeling1")

# Define the population sizes and names
populations <- list(
  "European American" = N$White,
  "African American" = N$Black,
  "Total US" = N$Total
)

# Define the database sizes and fractions
DB.sizes <- c(1e6, 5e6, 10e6)
db.frac <- c(0.05, 0.8, 1)

# Calculate the probabilities for each population and database fraction
prob_data <- calc_prob_db_frac(p, DB.sizes, db.frac, populations)

# Create and display the ggplot object
prob_plot <- ggplot_prob(prob_data, my.cols)
print(prob_plot)

# Print the table of final probabilities
# print(prob_data)

```



```{r plt-diffs}
# Function to generate ggplot object with populations in different colors
ggplot_prob_combined <- function(data, my.cols) {
  plot <- ggplot(data, aes(x = p, y = Probability, color = Population, group = interaction(Population, factor(DB.size)))) +
    geom_point() +
    geom_line() +
    scale_color_manual(values = my.cols, name = "Population") +
    labs(x = "p (degree of cousin)", y = "Probability of at least one p-th cousin in database") +
    theme_minimal() +
    facet_grid(Fraction ~ factor(DB.size), 
               labeller = labeller(Fraction = function(x) sprintf("%.0f%%", as.numeric(x) * 100),
                                                               DB.size = function(x) sprintf("%gM", x / 1e6)))
  
  function(x) formatC(x / 1e6, format = "f", digits = 0, big.mark = ",")
  

  return(plot)
}

# Set color palette for graphs
my.cols <- wes_palette("Darjeeling1", n = 3, type = "continuous")

# Create and display the ggplot object with populations in different colors
prob_combined_plot <- ggplot_prob_combined(prob_data, my.cols)
print(prob_combined_plot)

```



## Number of p-th degree cousins

```{r num-cousins}
# Function to calculate the number of p-th degree cousins
calc_cousins <- function(p, DB.size, N) {
  num_cousins <- 4^(p) * DB.size / (N / 2)
  return(num_cousins)
}

# Function to calculate the number of p-th degree cousins for different database fractions
calc_cousins_db_frac <- function(p, DB.sizes, db.frac, N) {
  data <- data.frame(p = integer(), Population = as.character(), DB.size = double(), Cousins = double(), Fraction = double())

  for (pop_name in names(N)) {
    for (i in 1:length(db.frac)) {
      for (j in 1:length(DB.sizes)) {
        DB.size <- DB.sizes[j] * db.frac[i]
        cousins <- calc_cousins(p, DB.size, N[[pop_name]])
        data <- rbind(data, data.frame(p = p, Population = rep(pop_name, length(p)), DB.size = rep(DB.sizes[j], length(p)), Cousins = cousins, Fraction = rep(db.frac[i], length(p))))
      }
    }
  }

  return(data)
}

# Function to generate ggplot object
ggplot_cousins <- function(data, my.cols) {
  plot <- ggplot(data, aes(x = p, y = Cousins, color = factor(DB.size), group = factor(DB.size))) +
    geom_point() +
    geom_line() +
    scale_color_manual(values = my.cols, name = "Database size (Millions)", labels = c("1", "5", "10")) +
    labs(x = "p (degree of cousin)", y = "Number of p-th degree cousins in database") +
    theme_minimal() +
    facet_grid(Fraction ~ Population, labeller = labeller(Fraction = function(x) sprintf("%.0f%%", as.numeric(x) * 100), Population = c("European American" = "European American", "African American" = "African American", "Total US" = "Total US")))

  return(plot)
}

# Set up vector of database sizes to test
DB.sizes <- c(1e6, 5e6, 10e6)

# Define the database fractions
db.frac <- c(0.05, 0.8, 1)

# Define the population sizes and names
populations <- list(
  "European American" = N$White,
  "African American" = N$Black,
  "Total US" = N$Total
)

# Calculate the number of cousins for each population and database fraction
cousins_data <- calc_cousins_db_frac(p, DB.sizes, db.frac, populations)

# Create and display the ggplot object
cousins_plot <- ggplot_cousins(cousins_data, my.cols)
print(cousins_plot)

```


## Probability of a genetically detectable cousin

Below, we calculate the expected number of shared blocks of genetic material between cousins of varying degrees of relatedness. This is important because the probability of detecting genetic material that is shared between two individuals decreases as the degree of relatedness between them decreases. The code uses a Poisson distribution assumption to estimate the probability of two cousins sharing at least one, two, or three blocks of genetic material, based on the expected number of shared blocks of genetic material calculated from previous research.


```{r genetic-blocks}

# The variable 'meiosis' represents the number of meiosis events between cousins, where 'p' is the degree of relatedness (i.e. p = 1 for first cousins, p = 2 for second cousins, etc.)
meiosis <- p + 1

## Expected number of blocks shared between cousins
# 'E.num.blocks' is the expected number of blocks of shared genetic material between cousins based on the degree of relatedness and the number of meiosis events between them. This value is calculated based on previous research and is not calculated in this code.
E.num.blocks <- 2 * (33.8 * (2 * meiosis) + 22) / (2^(2 * meiosis - 1))

## Use Poisson assumption
# 'Prob.genetic' is the probability of two cousins sharing at least one block of genetic material based on the expected number of shared blocks calculated in the previous step. The calculation uses a Poisson distribution assumption.
Prob.genetic <- 1 - exp(-E.num.blocks)

# 'prob.g.e.2.blocks' is the probability of two cousins sharing at least two blocks of genetic material based on the expected number of shared blocks calculated in the previous step. The calculation uses a Poisson distribution assumption.
prob.g.e.2.blocks <- 1 - sapply(E.num.blocks, function(expected.num) {sum(dpois(0:1, expected.num))})

# 'prob.g.e.3.blocks' is the probability of two cousins sharing at least three blocks of genetic material based on the expected number of shared blocks calculated in the previous step. The calculation uses a Poisson distribution assumption.
prob.g.e.3.blocks <- 1 - sapply(E.num.blocks, function(expected.num) {sum(dpois(0:2, expected.num))})


```

### General

```{r plt-genetic-blocks, fig.cap="Probabilities of detecting a genetic cousin in a database based on shared genomic blocks. Blue lines represent cousins with at least one genomic block, orange dotted and red lines represent cousins with at least two and three genomic blocks, respectively. The legend specifies the type of cousin being represented by each line."}

## Plot for number of shared blocks with p-th degree cousins
# Set layout of plot
layout(t(1))

# Set color palette for plot
my.cols2<-wes_palette("FantasticFox1")[3:5]

# Create a blank plot with labeled axes
plot(c(1,8),c(0,1),type="n",ylab="Probability p-th cousin \"detectable\"",xlab="p.(degree of cousin)")

# Add points for probability of detecting pth cousin with genomic blocks using colors from my.cols2
points(p,Prob.genetic,col=my.cols2[1],pch=19,type="b",lwd=2)
points(p,prob.g.e.2.blocks,col=my.cols2[2],pch=19,type="b",lwd=2)
points(p,prob.g.e.3.blocks,col=my.cols2[3],pch=19,type="b",lwd=2)

# Add a legend to the plot
legend(x="topright",legend=c("Cousins (w. >0 genomic blocks)","Cousins (w. >1 genomic blocks)","Cousins (w. >2 genomic blocks)"),col=my.cols2[1:3],lty=1)

```


### Relative to database size

```{r plt-num-cousins-db}
# Function to calculate expected number of p-th degree cousins based on shared genetic blocks
calc_gen_cousins <- function(p, DB.size, N, prob) {
  num.cousins <- 4^(p) * DB.size / (N / 2)
  return(num.cousins * prob)
}

# Function to calculate expected number of p-th degree cousins based on shared genetic blocks for different database fractions
calc_gen_cousins_db_frac <- function(p, DB.sizes, db.frac, N, prob) {
  data <- data.frame(p = integer(), Population = character(), DB.size = double(), Gen_Cousins = double(), Fraction = double())

  for (pop_name in names(N)) {
    for (i in 1:length(db.frac)) {
      for (j in 1:length(DB.sizes)) {
        DB.size <- DB.sizes[j] * db.frac[i]
        num_cousins <- calc_gen_cousins(p, DB.size, N[[pop_name]], prob)
        data <- rbind(data, data.frame(p = p, Population = rep(pop_name, length(p)), DB.size = rep(DB.sizes[j], length(p)), Gen_Cousins = num_cousins, Fraction = rep(db.frac[i], length(p))))
      }
    }
  }

  return(data)
}

# Function to generate ggplot object for expected number of p-th degree cousins based on shared genetic blocks
ggplot_gen_cousins <- function(data, my.cols) {
  plot <- ggplot(data, aes(x = p, y = Gen_Cousins, color = factor(DB.size), group = factor(DB.size))) +
    geom_point() +
    geom_line() +
    scale_color_manual(values = my.cols, name = "Database size (Millions)", 
                       labels = format(unique(data$DB.size) / 1e6, nsmall = 0)) +
    labs(x = "p (degree of cousin)", y = "Expected number of genetic p-th cousins in database") +
    theme_minimal() +
    # facet_grid(Fraction ~ Population, labeller = label_parsed)
  facet_grid(Fraction ~ Population, labeller = labeller(Fraction = function(x) sprintf("%.0f%%", as.numeric(x) * 100), Population = c("European American" = "European American", "African American" = "African American", "Total US" = "Total US")))

  return(plot)
}

# Calculate the expected number of p-th degree cousins based on shared genetic blocks for each population and database fraction
gen_cousins_data <- calc_gen_cousins_db_frac(p, DB.sizes, db.frac, populations, prob.g.e.3.blocks)

# Create and display the ggplot object
gen_cousins_plot <- ggplot_gen_cousins(gen_cousins_data, my.cols)
print(gen_cousins_plot)

```



